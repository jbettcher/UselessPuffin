buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:0.5.+'
    }
}
apply plugin: 'android'

repositories {
    mavenCentral()
}

def versionCodeBuilder = { api, screen, app -> Integer.parseInt(sprintf("%02d%02d%02d", [ api, screen, app ])) }

android {
    // Increment this to create a new build version. This overrides the value in AndroidManifest.xml
    def appCodeVersion = 1
    compileSdkVersion 18
    buildToolsVersion "18.0.1"
    // Default build code for main app - screen sizes 3 & 4

    defaultConfig {
        versionName "1.0.0"
        minSdkVersion 7
        targetSdkVersion 16
        versionCode versionCodeBuilder(minSdkVersion, 34, appCodeVersion)
    }

    signingConfigs {
        release {
            storeFile file("../android4all.keystore")
            keyAlias "android4allkey"
            storePassword android4AllStorePassword
            keyPassword android4AllStorePassword
        }

    }

    buildTypes {
        release {
            runProguard true
            proguardFile getDefaultProguardFile('proguard-android.txt')
            signingConfig signingConfigs.release
        }
    }

    productFlavors {
        'default' {
        }
        'lite' {
            versionCode versionCodeBuilder(defaultConfig.minSdkVersion, 12, appCodeVersion)
        }
    }
    sourceSets {
        android.sourceSets.lite {
            //res.srcDirs = ['src/main/res_lite']
        }
    }

}


android.applicationVariants.all { variant ->
    File out = variant.outputFile
    variant.outputFile = file(out.toString().replace('.apk', ".${android.defaultConfig.versionName}.apk"))

    // Install custom Manifest processing hooks for setting the supports-screen blocks for the lite manifest.
    // This is a work-around for broken/missing merge functionality with the manifests in the source sets
    // See https://groups.google.com/forum/#!msg/adt-dev/8igxEyihIlc/144LcUZ7QW4J
    if ( variant.name =~ /^Lite.*/ ) {
        variant.processManifest.doLast {
            def manifestFile = "${buildDir}/manifests/${variant.dirName}/AndroidManifest.xml"
            // hackity-hack. Would be nice to do this more programmatically
            setLiteManifestTargets manifestFile
        }
    }
}

// set some basic project properties for use later
project.ext.sourcePhotosDir = file('assets/source_photos')
project.ext.largeResources = [ 'hdpi', 'xhdpi', 'xxhdpi' ]

dependencies {
    compile 'com.android.support:support-v4:13.0.+'
}

task resizePhotos {
    // produce a hdpi/xhdpi png - 150 dpi
    // produce a ldpi/mdpi png in the default resource folder 300 dpi
    // TODO: output the count of input images for the project to use?
    def sizeMap = [ 'lite': [ 'folder': 'lite', 'px': 600 ], 'default': [ 'folder': 'main', 'px': 2100 ] ]
    FileTree photos = fileTree(dir: sourcePhotosDir).include('**/*.jpg').include('**/*.png')

    // closure for iterating over inputs/outputs
    def eachOutputFile = { cl ->
        photos.eachWithIndex { File file, num ->
            sizeMap.each { type, opts ->
                File outFile = project.file(sprintf("src/%s/res/drawable/photo_%02d.png", [ opts['folder'], num ]))
                cl( file, outFile, type, opts )
            }
        }
    }

    // Set up task inputs/outputs
    inputs.files photos.files
    def outFiles = []
    eachOutputFile { a, outfile, t, o -> outFiles << outfile }
    outputs.files files(outFiles)

    doLast {
        int total = outFiles.size()
        int current =  1
        eachOutputFile { File inFile, File outFile, type, opts ->
            logger.lifecycle "Resizing source photo $current/$total\r"
            logger.debug "Preparing $type for $inFile"
            if (!outFile.getParentFile().exists()) {
                outFile.getParentFile().mkdirs()
            }
            // Imagemagick dependency
            runCommand sprintf("convert -resize ${opts.get('px')}> %s %s", [ inFile.absolutePath, outFile.absolutePath ])
            current++
        }

    }
}

def verifyGitUnmodified(path) {
    runCommand("git diff-index --quiet HEAD -- $path", false)
}

def stripResources(List<String> res) {
    res.each { String type ->
        File dir = project.file("src/main/res/drawable-$type")
        if ( dir.exists() ) {
            if (!verifyGitUnmodified(dir)) throw new IllegalArgumentException("Git resources modified in $dir. Stash or commit your changes first.")
            logger.debug("Pruning $type resources")
            runCommand "rm -r $dir"
        }
    }
}

def restoreResources(List<String> res) {
    res.each { String type ->
        File dir = project.file("src/main/res/drawable-$type")
        runCommand "git reset HEAD $dir"
        runCommand "git checkout $dir"
    }
}

def runCommand(cmd, boolean abortOnError=true) {
    logger.debug("Executing $cmd")
    Process proc = cmd.execute()
    proc.err.eachLine { line -> logger.info(line) }
    int exitCode = proc.waitFor()
    if ( exitCode == 0 ) {
        return true
    }
    else if (abortOnError) {
        throw new IllegalArgumentException("Command $cmd failed with exit code $exitCode")
    }
    else {
        return false
    }
}

def prepareResourceExclusions(String flavor) {
    switch (flavor.toLowerCase()) {
        case 'lite':
            stripResources largeResources
            break
        default:
            restoreResources largeResources
    }
}

// cleanup after the merge resources step
def restoreResourceExclusions(String flavor) {
    restoreResources largeResources
}

// Pretty hacky.  Modifies the Lite version manifest to target specific screens rather than all
// screens as in the main manifest.  If Gradle would do more of a manifest merge on supports-screen
// this wouldn't be necessary.  See groups link in the caller
def setLiteManifestTargets(manifestFile) {
    ['largeScreens', 'xlargeScreens'].each { scr ->
        runCommand([ 'sed', '-i', '', "s/$scr=\"true\"/$scr=\"false\"/g", manifestFile ])
    }
}

/*
Gradle doesn't really have a good way of excluding resources from the default build for a particular
build flavor. This adds a task to execute before all of the mergeResources tasks to prune any
extra resources before the build starts.
*/
gradle.taskGraph.addTaskExecutionGraphListener(
    [graphPopulated: { graph ->
        def p = ~/merge(Default|Lite).*Resources/
        graph.getAllTasks().each { Task task ->
            def matcher = p.matcher(task.name)
            if (matcher.find()) {
                task.doFirst { prepareResourceExclusions(matcher[0][1]) }
                task.doLast { restoreResourceExclusions(matcher[0][1]) }
            }
        }
    }] as TaskExecutionGraphListener
)
