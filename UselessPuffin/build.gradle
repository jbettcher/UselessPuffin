buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:0.5.+'
    }
}
apply plugin: 'android'

repositories {
    mavenCentral()
}

def versionCodeBuilder = { api, screen, app -> Integer.parseInt(sprintf("%02d%02d%02d", [ api, screen, app ])) }

android {
    // Increment this to create a new build version. This overrides the value in AndroidManifest.xml
    def appCodeVersion = 1
    compileSdkVersion 18
    buildToolsVersion "18.0.1"
    // Default build code for main app - screen sizes 3 & 4

    defaultConfig {
        versionName "1.0.0"
        minSdkVersion 7
        targetSdkVersion 16
        versionCode versionCodeBuilder(minSdkVersion, 34, appCodeVersion)
    }

    productFlavors {
        'default' {
        }
        'lite' {
            versionCode = versionCodeBuilder(defaultConfig.minSdkVersion, 12, appCodeVersion)
        }
    }
    sourceSets {
        android.sourceSets.lite {
            res.srcDirs = ['src/main/res_lite']
        }
    }
}

android.applicationVariants.all { variant ->
    File out = variant.outputFile
    variant.outputFile = file(out.toString().replace('.apk', ".${android.defaultConfig.versionName}.apk"))
}

// set some basic project properties for use later
project.ext.sourcePhotosDir = file('assets/source_photos')
project.ext.largeResources = [ 'hdpi', 'xhdpi', 'xxhdpi' ]

dependencies {
    compile 'com.android.support:support-v4:13.0.+'
}

task resizePhotos {
    // produce a hdpi/xhdpi png - 150 dpi
    // produce a ldpi/mdpi png in the default resource folder 300 dpi
    // TODO: output the count of input images for the project to use?
    def sizeMap = [ 'lite': [ 'folder': 'res_lite', 'px': 600 ], 'default': [ 'folder': 'res', 'px': 2100 ] ]
    FileTree photos = fileTree(dir: sourcePhotosDir).include('**/*.jpg').include('**/*.png')

    // closure for iterating over inputs/outputs
    def eachOutputFile = { cl ->
        photos.eachWithIndex { File file, num ->
            sizeMap.each { type, opts ->
                File outFile = project.file(sprintf("src/main/%s/drawable/photo_%02d.png", [ opts['folder'], num ]))
                cl( file, outFile, type, opts )
            }
        }
    }

    // Set up task inputs/outputs
    inputs.files photos.files
    def outFiles = []
    eachOutputFile { a, outfile, t, o -> outFiles << outfile }
    outputs.files files(outFiles)

    doLast {
        int total = outFiles.size()
        int current =  1
        eachOutputFile { File inFile, File outFile, type, opts ->
            logger.lifecycle "Resizing source photo $current/$total\r"
            logger.debug "Preparing $type for $inFile"
            if (!outFile.getParentFile().exists()) {
                outFile.getParentFile().mkdirs()
            }
            String cmdLine = sprintf("convert -resize ${opts.get('px')}> %s %s", [ inFile.absolutePath, outFile.absolutePath ])
            logger.debug cmdLine
            Process proc = cmdLine.execute()
            proc.err.eachLine { line -> logger.info line }
            if ( proc.waitFor() != 0 ) {
                throw new RuntimeException("Imagemagick convert failed")
            }
            current++
        }

    }
}

def verifyGitUnmodified(path) {
    runCommand("git diff-index --quiet HEAD -- $path", false)
}

def stripResources(List<String> res) {
    res.each { String type ->
        File dir = project.file("src/main/res/drawable-$type")
        if ( dir.exists() ) {
            if (!verifyGitUnmodified(dir)) throw new IllegalArgumentException("Git resources modified in $dir. Stash or commit your changes first.")
            logger.debug("Pruning $type resources")
            runCommand "rm -r $dir"
        }
    }
}

def restoreResources(List<String> res) {
    res.each { String type ->
        File dir = project.file("src/main/res/drawable-$type")
        runCommand "git reset HEAD $dir"
        runCommand "git checkout $dir"
    }
}

def runCommand(String cmd, boolean abortOnError=true) {
    logger.debug("Executing $cmd")
    Process proc = cmd.execute()
    proc.err.eachLine { line -> logger.info(line) }
    int exitCode = proc.waitFor()
    if ( exitCode == 0 ) {
        return true
    }
    else if (abortOnError) {
        throw new IllegalArgumentException("Command $cmd failed with exit code $exitCode")
    }
    else {
        return false
    }
}

def prepareResourceExclusions(String flavor) {
    switch (flavor.toLowerCase()) {
        case 'lite':
            stripResources largeResources
            break
        default:
            restoreResources largeResources
    }
}

/*
Gradle doesn't really have a good way of excluding resources from the default build for a particular
build flavor. This adds a task to execute before all of the mergeResources tasks to prune any
extra resources before the build starts.
*/
gradle.taskGraph.addTaskExecutionGraphListener(
    [graphPopulated: { graph ->
        def p = ~/merge(Default|Lite).*Resources/
        graph.getAllTasks().each { Task task ->
            def matcher = p.matcher(task.name)
            if (matcher.find()) {
                task.doFirst { prepareResourceExclusions(matcher[0][1]) }
            }
        }
    }] as TaskExecutionGraphListener
)
