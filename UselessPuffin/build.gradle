buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:0.5.+'
    }
}
apply plugin: 'android'

repositories {
    mavenCentral()
}

def versionCodeBuilder = { api, screen, app -> Integer.parseInt(sprintf("%02d%02d%02d", [ api, screen, app ])) }
// set some basic project properties for use later
project.ext.sourcePhotosDir = file('assets/source_photos')
project.ext.largeResources = [ 'hdpi', 'xhdpi', 'xxhdpi' ]
project.ext.screenMatrix   = [
    'lite' : [
        'small' : [ 'ldpi', 'mdpi', 'hdpi', 'xhdpi' ],
        'normal': [ 'ldpi', 'mdpi' ]
    ],
    'default': [
        'normal': [ 'hdpi', 'xhdpi' ],
        'large' : [ 'ldpi', 'mdpi', 'hdpi', 'xhdpi' ],
        'xlarge': [ 'ldpi', 'mdpi', 'hdpi', 'xhdpi' ]
    ]
]


android {
    // Increment this to create a new build version. This overrides the value in AndroidManifest.xml
    def appCodeVersion = 3
    compileSdkVersion 18
    buildToolsVersion "18.0.1"

    defaultConfig {
        versionName "1.0.2"
        minSdkVersion 7
        targetSdkVersion 16
    }

    signingConfigs {
        release {
            storeFile file("../android4all.keystore")
            keyAlias "android4allkey"
            storePassword android4AllStorePassword
            keyPassword android4AllStorePassword
        }

    }

    buildTypes {
        release {
            runProguard true
            proguardFile getDefaultProguardFile('proguard-android.txt')
            signingConfig signingConfigs.release
        }
    }

    productFlavors {
        'default' {
            minSdkVersion 7
            versionCode versionCodeBuilder(8, 25, appCodeVersion)
        }

        'lite' {
            minSdkVersion 7
            versionCode versionCodeBuilder(8, 24, appCodeVersion)
        }
    }
}


android.applicationVariants.all { variant ->
    File out = variant.outputFile
    variant.outputFile = file(out.toString().replace('.apk', ".${android.defaultConfig.versionName}.apk"))

    // Install custom Manifest processing hooks for setting the expansions for the compatible-screens blocks.
    // See https://groups.google.com/forum/#!msg/adt-dev/8igxEyihIlc/144LcUZ7QW4J
    variant.processManifest.doLast {
        def manifestFile = "${buildDir}/manifests/${variant.dirName}/AndroidManifest.xml"
        addCompatibleScreens variant.productFlavors[0].name, manifestFile
    }
}

dependencies {
    compile 'com.android.support:support-v4:18.0.+'
}

task resizePhotos {
    // produce a hdpi/xhdpi png - 150 dpi
    // produce a ldpi/mdpi png in the default resource folder 300 dpi
    // TODO: output the count of input images for the project to use?
    def sizeMap = [ 'lite': [ 'folder': 'lite', 'px': 600 ], 'default': [ 'folder': 'main', 'px': 2100 ] ]
    FileTree photos = fileTree(dir: sourcePhotosDir).include('**/*.jpg').include('**/*.png')

    // closure for iterating over inputs/outputs
    def eachOutputFile = { cl ->
        photos.eachWithIndex { File file, num ->
            sizeMap.each { type, opts ->
                File outFile = project.file(sprintf("src/%s/res/drawable/photo_%02d.png", [ opts['folder'], num ]))
                cl( file, outFile, type, opts )
            }
        }
    }

    // Set up task inputs/outputs
    inputs.files photos.files
    def outFiles = []
    eachOutputFile { a, outfile, t, o -> outFiles << outfile }
    outputs.files files(outFiles)

    doLast {
        int total = outFiles.size()
        int current =  1
        eachOutputFile { File inFile, File outFile, type, opts ->
            logger.lifecycle "Resizing source photo $current/$total\r"
            logger.debug "Preparing $type for $inFile"
            if (!outFile.getParentFile().exists()) {
                outFile.getParentFile().mkdirs()
            }
            // Imagemagick dependency
            runCommand sprintf("convert -resize ${opts.get('px')}> %s %s", [ inFile.absolutePath, outFile.absolutePath ])
            current++
        }

    }
}

def verifyGitUnmodified(path) {
    runCommand("git diff-index --quiet HEAD -- $path", false)
}

def stripResources(List<String> res) {
    res.each { String type ->
        File dir = project.file("src/main/res/drawable-$type")
        if ( dir.exists() ) {
            if (!verifyGitUnmodified(dir)) throw new IllegalArgumentException("Git resources modified in $dir. Stash or commit your changes first.")
            logger.debug("Pruning $type resources")
            runCommand "rm -r $dir"
        }
    }
}

def restoreResources(List<String> res) {
    res.each { String type ->
        File dir = project.file("src/main/res/drawable-$type")
        runCommand(['git', 'reset', 'HEAD', '--', dir])
        runCommand(['git', 'checkout', '--', dir])
    }
}

def runCommand(cmd, boolean abortOnError=true) {
    logger.debug("Executing $cmd")
    Process proc = cmd.execute()
    proc.err.eachLine { line -> logger.info(line) }
    int exitCode = proc.waitFor()
    if ( exitCode == 0 ) {
        return true
    }
    else if (abortOnError) {
        throw new IllegalArgumentException("Command $cmd failed with exit code $exitCode")
    }
    else {
        return false
    }
}

def prepareResourceExclusions(String flavor) {
    switch (flavor.toLowerCase()) {
        case 'lite':
            stripResources largeResources
            break
        default:
            restoreResources largeResources
    }
}

def String buildScreenMatrix(String flavor) {
    Map values = screenMatrix[flavor]
    if ( values != null ) {
        def supports = []
        values.each { size, densities ->
            densities.each { density ->
                supports << "<screen android:screenSize=\"$size\" android:screenDensity=\"$density\" />"
            }
        }
        return supports.join("\n")
    }
    else {
        return ""
    }
}

// cleanup after the merge resources step
def restoreResourceExclusions(String flavor) {
    restoreResources largeResources
}


def addCompatibleScreens(flavor, manifestFile) {
    File f = new File(manifestFile)
    String manifest = f.text
    String matrix = "<compatible-screens>\n" + buildScreenMatrix(flavor) + "\n<"
    manifest = manifest.replaceFirst(/(?ms)<compatible-screens>[^<]*</, matrix)
    f.withWriter { writer ->
        writer << manifest
    }
}

/*
Gradle doesn't really have a good way of excluding resources from the default build for a particular
build flavor. This adds a task to execute before all of the mergeResources tasks to prune any
extra resources before the build starts.
*/
gradle.taskGraph.addTaskExecutionGraphListener(
    [graphPopulated: { graph ->
        def p = ~/merge(Default|Lite).*Resources/
        graph.getAllTasks().each { Task task ->
            def matcher = p.matcher(task.name)
            if (matcher.find()) {
                task.doFirst { prepareResourceExclusions(matcher[0][1]) }
                task.doLast { restoreResourceExclusions(matcher[0][1]) }
            }
        }
    }] as TaskExecutionGraphListener
)
